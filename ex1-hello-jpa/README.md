# JPA에서 가장 중요한 2가지

1. 객체와 관계형 데이터베이스 매핑하기
2. 영속성 컨텍스트

## 영속성 컨텍스트

: Persistence Context
: JPA를 이해하는데 가장 중요한 용어
: "엔티티를 영구 저장하는 환경"이라는 의미 -> 엔티티를 DB에 저장하는 것이 아니라 영속성 컨텍스트에 저장한다는 의미(persist - 영속화)

* Entity Manager Factory, Entity Manager

- 영속성 컨텍스트는 논리적인 개념
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근

## 엔티티의 생명주기

- 비영속(new/transient)
  : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태

```java
Member member = new Member();
member.setId("member1");
member.setUserName("회원1");
// 객체만 생성된 상태(비영속 상태)
```

### - 영속(managed)

: 영속성 컨텍스트에 관리되는 상태

```java
EntityManager em = emf.createEntityManager();
em.getTransaction().begin();
em.persist(member); // persist메소드를 통한 영속화
```

### - 준영속(detached)

: 영속성 컨텍스트에 저장되었다가 분리된 상태 ₩em.detached(member);₩

### - 삭제(removed)

: 삭제된 상태
`em.remove(member);`

## 영속성 컨텍스트의 이점

- 1차캐시
- 동일성(Identity) 보장
  : 1차 캐시로 반복 가능한 읽기(repeatable read) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 어플리케이션 차원에서 제공한다.
- 트랜잭션을 지원하는 쓰기지연(transactional write-behind)
  : commit(); 을 하면 영속성 컨텍스트에서 flush()되며, 데이터베이스에 INSERT/UPDATE Query를 날린다.
- 변경 감지(dirty checking)
- 지연로딩(lazy Loading)

### 플러시

: 영속성 컨텍스트의 변경내용을 데이터베이스에 반영

#### 플러시 발생

- 변경 감지
- 쓰기 지연 SQL 저장소에 수정된 엔티티 등록
- 쓰기 지연 저장소의 쿼리를 데이터베이스 전송(등록, 수정, 삭제 쿼리)

#### 영속성 컨텍스트 플러시 방법

1. em.flush() - 직접 호출
2. transaction commit
3. JPQL 쿼리 실행

#### 플러시 특징

1. 영속성 컨텍스트를 비우지 않음
2. 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
3. 트랜잭션이라는 작업 단위가 중요함.(커밋 직전에만 동기화하면 됨.)

### 준영속

영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
영속성 컨텍스트가 제공하는 기능을 사용하지 못한다.

- 1차캐시, 동일성 보장, 쓰기지연, 지연로딩 등..

#### 준영속 상태로 만드는 방법

```java
// 영속 상태
Member member = em.find(Member.class, 150L);
member.setName("chage"); // Dirty Checking

// 준영속 상태(jpa에서 관리 안함)
// 특정 엔티티만 준영속 상태로 만드는 경우
em.detach(member);

// 영속성 컨텍스트 전체를 초기화 하는 경우
em.clear();

// 영속성 컨텍스트를 종료
em.close();

```

* * * 

## 앤티티와 매핑

### 객체와 테이블 매핑

- 객체와 테이블 매핑 : `@Entity`, `@Table`
  `@Entity`
  : JPA가 관리하는 엔티티
  : JPA를 사용패서 테이블과 매핑할 클래스는 필수

* 주의 JPA스펙상 기본 생성자는 있어야 함.(public or protected)
  final class, enum, interface, inner class 사용불가 저장할 필드에 final 사용 금지

#### 속성

- name JPA에서 사용할 엔티티 이름 지정 기본 값 : 클래스 이름 같은 클래스 이름이 없으면 가급적 기본값 사용

`@Table`
엔티티와 매핑할 테이블 지정

- 필드와 컬럼 매핑 : `@Column`
- 기본 키 매핑 : `@Id`
- 연관관계 매핑 : `@ManyToOne`n `@JoinColumn`

### 데이터베이스 스키마 자동 생성

DDL을 어플리케이션 실행 시점에 자동 생성 테이블 중심 -> 객체 중심 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성 운영에서는 사용X(개발 단계에서만 사용)

hibernate.hbm2ddl.auto

- create : 기존 테이블 삭제 후 생성(drop + create)
- create-drop : 종료 시점에 drop
- update : 변경분만 반영(컬럼 삭제는 불가능)
- validate : 엔티티와 테이블이 정상 매핑되었는지만 확인
- none : 사용하지 않음

* 주의 운영장비에는 절대 create, create-drop, update사용하면 안됨. 개발 초기에는 create / update 테스트 서버는 update / validate 스테이징과 운영 서버는
  validate / none

DDL 생성 기능
: 런타임 중에 영향(JPA의 실행 로직에 영향)을 주는 것이 아니라 DB에 영향을 줌

### 필드와 컬럼 매핑

`@Column`
name : 필드와 매핑할 테이블의 컬럼이름 insertable, updateable : 등록, 변경가능 여부 nullable : null값의 허용 여부 unique : 유니크 제약 조건
columnDefinition : 컬럼 정의를 직접하고 싶은 경우(varchar(100) default 'EMPTY')
length : 문자 길이 제약 조건, String 타입에만 사용 precision scale : BigDecimal, BigInteger 타입에서 사용.

`@Enumerated`
Enum타입 매핑할 때 사용 Default == ORDINAL EnumType.ORDINAL : 순서를 저장(문자X)
EnumType.STRING  : 이름을 저장

`@Temporal`
java.util.Date, java.util.Calendar를 매핑할 때 사용 java8이후는 LocalDateTime을 지원하기 때문에 @Temporal을 사용하지 않아도 무방함.

`@Lob`
지정 가능한 속성은 별도로 없음. 매핑하는 타입이 문자면 CLOB 나머지는 BLOB

`@Transient`
필드와 매핑하지 않는 경우 사용

### 기본 키 매핑

직접 할당 `@Id`
자동생성 ( @GeneratedValue)

- IDENTITY : DB에 위임(MYSQL)
- persist시점에 query가 날라간다. -> query를 모아뒀다가 persist시점에 flush하는 것이 불가능함.

 ```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

```sql
create table Member (
       id bigint generated by default as identity,
        name varchar(255),
        primary key (id)
    )

insert 
        into
            Member
            (id, name) 
        values
            (null, ?)
```

- SEQUENCE : DB SEQUENCE OBJECT, ORACLE
    - @SequenceGenerator 필요

 ```java
@Entity
@SequenceGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        sequenceName = "MEMBER_SEQ",
        initialValue = 1, allocationSize = 1
)
public class Member {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE,
            generator = "MEMBER_SEQ_GENERATOR")
    private Long id;
    private String name;
}
```

```sql
Hibernate: create sequence MEMBER_SEQ start with 1 increment by 1
Hibernate: 
    
    create table Member (
       id bigint not null,
        name varchar(255),
        primary key (id)
    )
insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
```

- TABLE : 키 생성용 테이블 사용
    - @TableGenerator 사용 장점 : 모든 데이터베이스에 적용 가능 단점 : 성능이 상대적으로 떨어진다.

- AUTO : 방언에 따라 자동 지정

기본 값은 auto(방언에 따라 자동 지정)


* * * 

## 연관관계 매핑 기초

### 연관관계가 필요한 이유

객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.

- 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다.
- 객체는 참조로 연관된 객체를 찾는다.

### 단방향 연관관계

### 단방향

: 2개의 객체 중 한 쪽만 참조하는 관계 👉 [회원 → 팀] 또는 [팀 → 회원]

### 양방향

: 2개의 객체가 서로를 참조하는 관게 👉 [회원 → 팀] 그리고 [팀 → 회원]

객체는 가급적이면 단방향이 좋다.

### 연관관계의 주인과 mappedBy

객체와 테이블이 관계를 맺는 차이

- 객체 연관관계 = 2개 회원 -> 팀 팀 -> 회원 각각의 단방향 연관관계 2개

- 테이블 연관관계 = 1개 (PFK)
  회원 <-> 팀 (양방향)

즉, 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 양방향 관계 2개인 것이다. 객체를 양방향으로 참조하려면 <STRONG>단방향 연관관계</STRONG>를 2개 만들어야 한다. 테이블은 <STRONG>
외래 키</STRONG> 하나로 두 테이블의 연관관계를 관리한다.

#### 양방향 매핑 규칙

- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 외래키를 관리(등록, 수정)
- `주인이 아닌쪽은 읽기만 가능하다.`
- 주인은 mappedBy 속성 사용 안함.
- 주인이 아니면 mappedBy 속성으로 주인 지정.

** 연관관계의 주인을 누구로 설정할 것인가 ?

- 외래 키가 있는 곳을 주인으로 지정 비즈니스 로직 기준으로 하면 안된다. 외래 키의 위치를 기준으로 해야 한다.

#### 양방향 매핑시 빈번한 실수

- 연관관계의 주인에 값을 입력하지 않음.(member의 team은 null)

```java
Team team = new Team();
team.setName("TEAMA");

em.persist(team);

Member member = new Member();
member.setUsername("Harry Park");
team.getMembers().add(member);

em.persist(member);
```

- 순수한 객체 관계를 고려하면 양쪽 다 값을 입력해야 한다.

```java
Team team = new Team();
team.setName("TEAMA");
em.persist(team);

Member member = new Member();
member.setUsername("Harry Park");

// 양쪽 다 값 설정
member.setTeam(team);
team.getMembers().add(member);

em.persist(member);
```

🚨 추천내용

1. 순수한 객체 관계를 고려하면 양쪽 다 값을 입력
2. 연관관계 편의 메소드를 사용
3. 양방향 매핑시 무한 루프를 조심 예) toString(), lombok, JSON 생성 라이브러리

## 다양한 연관관계 매핑

고려해야할 사항

1. 다중성
2. 단방향, 양방향

- 테이블
  : 외래 키 하나로 양쪽 조인 가능
  : 방향이라는 개념 없음
- 객체
  : 참조용 필드가 있는 쪽으로만 참조 가능
  : 한쪽만 참조하면 단방향
  : 양쪽 서로 참조하면 양방향

3. 연관관계의 주인 주인 : 외래 키를 관리하는 참조 주인 반대편 : 외래 키에 영향 X, 단순 조회만

### 다대일[N:1] - @ManyToOne

가장 많이 사용하는 연관관계(반대는 일대다)

- 단방향

```java
...
    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
...
```

- 양방향 테이블에는 영향을 주는 것이 아니고 객체관의 관계만 생성됨

```java
public class Member {
...
    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
...
}
public class Team {
...
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
...
}
```

### 일대다[1:N] - @OneToMany

- 단방향 일대다 단방향은 1이 연관관계의 주인이다. 테이블 일대다 관계는 항상 다 쪽에 외래키가 있다. 객체는 테이블의 반대에서 외래 키를 관리한다는 특징이 있다. @JoinColumn을 넣어주어야 함. 생략되면
  default @JoinTable

```java
public class Team {
	@OneToMany
    @JoinColumn(name = "TEAM_ID")
    private List<Member> members = new ArrayList<>();

    public List<Member> getMembers() {
        return members;
    }
}    
```

단점 엔티티가 관리하는 외래 키가 다른 테이블에 있다. 연관관계 관리를 위해 추가로 UPDATE SQL이 실행됨.

! 다대일 양방향 매핑을 사용하는 것이 설계의 관점에서 떨어지더라도 유지 보수성에서 좋다.

- 양방향 일대다 양방향 매핑은 존재하지 않는다.(🚨 실무 사용 금지 ❌)
  @JoinColumn(updatable = false, insertable = false) 키워드만 추가 된다.

```java
public class Member {
...
	@ManyToOne
	// 읽기 전용 설정
    @JoinColumn(name = "TEAM_ID", insertable = false, updatable = false)
    private Team team;
...
}

public class Team {
	@OneToMany
    @JoinColumn(name = "TEAM_ID")
    private List<Member> members = new ArrayList<>();

    public List<Member> getMembers() {
        return members;
    }
}    
```

### 일대일[1:1] - @OneToOne

일대일 관계는 그 반대도 일대일 주 테이블이나 대상 테이블 중 외래 키 선택 가능

- 주 테이클에 외래 키
  : 주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾는다.
  : 객체지향 개발자 선호
  : JPA 매핑 편리

* 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인이 가능
* 단점 : 값이 없으면 외래 키에 null이 허용된다.

- 대상 테이블에 외래 키
  : 대상 테이블에 외래 키가 존재
  : 전통적인 데이터베이스 개발자 선호

* 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조가 유지된다.
* 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩된다.

외래 키에 데이터베이스 유니크(UNIQUE) 제약조건 추가

### 다대다[N:N] - @ManyToMany

: 실무에서 사용안하는 것 권장

- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계로 표현할 수 없다. (연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함.)
- 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능

`@ManyToMany` 사용
`@JoinTable`로 연결 테이블 지정

* 한계점

- 연결 테이블이 단순히 연결만 하고 끝나지 않음
- 주문시간, 수량 같은 데이터가 들어올 수 있다.

* * * 

## 상속관계 매핑

관계형 데이터베이스는 상속 관계가 없다. 슈퍼 타입, 서브 타입 관계라는 모델링 기법이 있는데, 객체 상속과 유사하다. 상속관계 매핑 : 객체의 상속구조와 DB의 슈퍼타입, 서브타입 관계를 매핑하는 것

### 구현 방법

JPA기본 전략은 싱글 테이블 전략

1. 각 테이블로 구현 - 조인 전략 장점

- 테이블 정규화
- 외래 키 참조 무결성 제약조건 활용가능
- 저장공간 효율화 단점
- 조회시 조인을 많이 사용한다, 성능 저하
- 조회 쿼리가 복잡함
- 데이터 저장시 INSERT SQL이 2번 호출된다.


2. 통합 테이블로 변환 - 단일 테이블 전략

- 필수 값으로 @DincriminationColumn을 생성해줌(DTYPE)

장점

- 조인이 필요없어 조회 성능이 빠르다.
- 쿼리가 단순하다. 단점
- 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다.
- 단일 테이블에 모든 것을 저장하므로, 테이블이 커질 수 있고 상황에 따라 조회 성능이 느려질 수 있다.


3. 서브타입 테이블로 변환 - 구현 클래스마다 테이블 전략 조인 전략과 비슷하지만, 최상위 클래스를 없애고 서브타입으로만 사용 명확하게 타입을 지정해서 조회하는 경우에는 좋으나, 불명확하게 조회되는 경우에는
   union이 걸려서 나가기 때문에 성능이 상대적으로 떨어짐

장점

- not null 사용 가능
- 서브 타입을 명확하게 구분해서 처리할 때 효과

단점

- 자식 테이블을 통합해서 쿼리하기 어렵다.
- 조회시 성능 느림

### 매핑정보 상속

@MappedSuperclass
: 상속관계 매핑과는 크게 관련 없음.
: 공통 매핑 정보가 필요할 때 사용한다.(id, name)
: Entity, MappedSuperClass로 지정된 경우에만 사용 가능하다.

- 상속 관계 매핑 X
- 엔티티가 아니고 속성만 내려주는 것
- 자식 클래스에 매핑 정보만 제공
- 상속받은 속성으로는 조회가 불가능함(em.find(BaseEntity,class.. );)
- 직접 생성해서 사용할 일이 없으므로 추상 클래스로 사용

* * * 

## 프록시

em.getReference() : 데이터 베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

특징

- 실제 클래스를 상속 받아서 만들어진다.
- 실제 클래스와 겉 모양이 같다.
- 사용하는 입장에서 진짜 객체인지, 프록시 객체인지 구분하지 않고 사용하면 된다.
- 프록시 객체는 실제 객체의 참조를 보관한다.
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.

프록시 객체의 특징

1. 처음 사용할 때 한 번만 초기화된다.
2. 프록시 객체를 초기화 할 때, 프록시 객체가 엔티티로 바뀌는 것이 아니라 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근.
3. 프록시 객체는 원본 엔티티를 상속받는다. -> 타입 체크시 주의해야한다.(==비교 실패, 대신 instance of 사용)
4. 영속성 컨텍스트에 찾는 엔티티가 이미 있으면, em.getReference()를 호출해도 실제 엔티티를 반환한다.
5. 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제가 발생한다.
   (하이버 네이트는 org.hibernate.LazyInitializationException 예외 발생)

프록시 확인

```java
 // Proxy 인스턴스의 초기화 여부
System.out.println("isLoaded = " + emf.getPersistenceUnitUtil().isLoaded(refMember));

// 프록시 클래스 확인
System.out.println("Proxy class = " + refMember.getClass());

// 프록시 강제 초기화
Hibernate.initialize(refMember);
```

## 즉시 로딩과 지연로딩

`fetch = FetchType.LAZY`
`fetch = FetchType.EAGER`

프록시와 즉시로딩 주의

- 가급적 지연 로딩만 사용(특히 실무)
- 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생한다.
- 즉시 로딩은 JPQL에서 N + 1 을 일으킨다.
- @ManyToOne, @OneToOne은 기본이 즉시 로딩
- @OneToMany, @ManyToMany는 기본이 지연 로딩

모든 연관관계에 지연 로딩을 사용할 것!
(실무에서 즉시로딩 사용 금지)

- JPQL fetch 조인이나, 엔티티 그래프 기능 사용

## 영속성 전이(CASCADE)

: 특정 엔티티를 영속 상태로 만들 때, 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용

! 연관관계 매핑하는 것과는 관련 없음

### 종류

ALL : 모두 적용 PERSIST : 영속 REMOVE : 삭제 MERGE : 병합 REFRESH : REFRESH DETACH : DETACH

## 고아객체

고아객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 것 orphanRemoval = true

! 주의 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능

- 참조하는 곳이 하나 일때 사용(첨부파일 등)
- 특정 엔티티가 개인 소유할 때 사용
  `@OneToOne`, `@OneToMany`만 가능

영속성 전이 + 고아객체, 생명주기 CascadeType.ALL + orphanRemoval= true 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거 두 옵션 모두
활성화하면 부모 엔티티를 통해 자식의 생명주기 관리 할 수 있다.

도메인 주도 개발(DDD)의 Aggregate Root개념을 구현할 때 유용

### 값 타입

int, Integer, String처럼 단순히 값으로 사용하는 자바 기본타입이나 객체 식별자가 없고 값만 있어 변경시 추적이 불가능함.

1. 기본 값 타입

- 자바 기본 타입 (항상 값을 복사)
- 래퍼클래스
- String

: 생명주기를 엔티티에 의존한다.
: 값 타입은 공유하면 안된다. -> 래퍼클래스와 String은 공유 가능한 객체. 하지만 변경하지 않는게 좋음

2. 임베디드 타입

- embedded type, 복합 값 타입 (x, y 좌표 등)
  : 새로운 값 타입을 직접 정의
  : 주로 기본 값 타입을 모아서 만들어 복합 값 타입이라고도 한다.
  : int, String과 같은 값 타입

#### 사용방법

@Embeddable : 값 타입을 정의하는 곳에 사용 @Embedded : 값 타입을 사용하는 곳에 표시 기본 생성자필수

장점

- 재사용성
- 높은 응집도
- 생명주기를 소유한 엔티티에 의해 관리된다.

임베디드 타입과 테이블 매핑

- 임베디드 타입은 엔티티의 값일 뿐임
- 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.
- 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능하다.
- 잘 설계한 ORM은 매핑한 테이블의 수보다 클래스의 수가 더 많다.

@AttributeOverride 속성 재정의 @AttributeOverrides, @AttributeOverride를 사용해서 재정의

- 임베디드 값 타입이 null이면 매핑한 컬럼 값은 모두 null

3. 컬렉션 값 타입

- collection value type 값 타입과 불변객체 값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념

값 타입 공유 참조 임베디드 타입 값 타입을 여러 엔티티에서 공유하면 위험하다. side effect 발생

-> 값 타입의 공유는 복사해서 사용해야 한다.

한계

- 항상 값을 복사해서 사용하면 공유 참조로 인해 부작용은 피할 수 있다.
- 직접 정의한 값 타입은 자바의 기본 타입이 아니라 기본 객체 타입이다.
- 자바 기본 타입에 값을 대입하면 값을 복사한다.
- 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.
- 객체의 공유 참조는 피할 수 없다.

불변 객체(immutable object)

- 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단 가능하다.
- 값 타입은 불변 객체로 설계해야 한다.
- 불변 객체. 생성 시점 이후 절대 값을 변경할 수 없는 객체
- 생성자로만 값을 설정하고 수정자를 만들지 않으면 된다. 참고, Integer, String은 자바가 제공하는 대표적인 불변객체 -> 값을 변경하고자 하는 경우에는 새로운 인스턴스를 만들어야 함.

"불변이라는 작은 제약으로 큰 오류를 막을 수 있다."

값 타입의 비교

값 타입 : 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야한다.

- 동일성 비교 : 인스턴스의 참조 값을 비교, == 사용
- 동등성 비교 : 인스턴스의 값을 비교, equals()를 사용 값 타입은 equals()로 동등성 비교를 해야한다. -> equals와 hashcode를 적절하게 재정의 해주어야 한다.

3. 컬렉션 값 타입

- collection value type

값 타입을 하나 이상 저장할 때 사용 @ElementCollection, @CollectionTable 사용 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다. 컬렌션을 저장하기 위한 별도의 테이블이 필요하다.

참고 : 값 타입 컬렉션은 영속성 전이, 고아객체 제거 기능을 필수로 가진다.

제약사항

- 값 타입은 엔티티와 다르게 식별자 개념이 없다.
- 값은 변경하면 추적이 어렵다.
- 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 관련된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.

- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야한다.(null 입력 금지, 중복 저장 금지)

값 타입 컬렉션 대안 값 타입 컬렉션 대신에 일대다 관계를 고려 일대다 관계를 위한 엔티티를 만들고, 여기에 값 타입을 사용 영속성 전이 + 고아객체 제거를 사용해서 값 타입 컬렉션 처럼 사용


